{"data":{"site":{"siteMetadata":{"title":"Cube Blog","author":"memory"}},"markdownRemark":{"id":"66dc702f-0416-5725-ae3a-6fadb9fbf808","html":"<p>npm 是目前默认的 Node 包管理工具，在 javaScript 项目开发中得到了广泛使用。</p>\n<h2>node_modules</h2>\n<p>npm 使用 <code class=\"language-text\">npm install</code> 命令安装模块到<code class=\"language-text\">node_modules</code> 目录下。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&lt;</span>packageName<span class=\"token operator\">></span></code></pre></div>\n<blockquote>\n<p><code class=\"language-text\">node_modules</code> 路径查找机制：默认情况下，模块查找对应的依赖包时，<code class=\"language-text\">nodejs</code> 会尝试从当前模块所在的目录开始，尝试在它的  <code class=\"language-text\">node_modules</code> 文件夹里加载相应的模块，如果没有找到，那么就再向上一级目录移动，直到到达全局安装路径中的 <code class=\"language-text\">node_modules</code> 为止。</p>\n</blockquote>\n<h4>npm 5.x 安装组织 node_modules</h4>\n<ul>\n<li>\n<p>扁平化安装</p>\n<p>按照 <code class=\"language-text\">package.json</code> 里依赖的顺序依次解析，遇到新的包就将其安装在第一级目录，后续安装时如果遇到一级目录已经存在的包，会按照约定版本进行判断。如果符合版本约定就会忽略，否则会将其依次安装在依赖包的目录下。</p>\n</li>\n<li>\n<p>增加了 <code class=\"language-text\">package-lock.json</code> 文件</p>\n<p>用以精确描述 <code class=\"language-text\">node_modules</code> 目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"glob\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n<span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"7.1.3\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"resolved\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"https://registry.npmjs.org/glob/-/glob-7.1.3.tgz\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"integrity\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"sha512-vcfuiIxogLV4DlGBHIUOwI0IbrJ8HWPc4MU7HzviGeNho/UJDfi6B5p3sHeWIQ0KGIU0Jpxi5ZHxemQfLkkAwQ==\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"requires\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"fs.realpath\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^1.0.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inflight\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^1.0.4\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"inherits\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"minimatch\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^3.0.4\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"once\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^1.3.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"path-is-absolute\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"^1.0.0\"</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>以 <code class=\"language-text\">glob</code> 为例，<code class=\"language-text\">package-lock.json</code> 主要由以下几个字段进行描述：</p>\n<ul>\n<li><code class=\"language-text\">version</code> 包唯一的版本号</li>\n<li><code class=\"language-text\">resolved</code> 安装源</li>\n<li><code class=\"language-text\">integrity</code> hash 值，表明包的完整性，用来验证包是否已经失效</li>\n<li><code class=\"language-text\">dev</code> 如果为true，则此依赖关系仅是顶级模块的开发依赖关系或者是一个的传递依赖关系</li>\n<li><code class=\"language-text\">requires</code> 该依赖包所需要的依赖项</li>\n</ul>\n</li>\n</ul>\n<h2>依赖包</h2>\n<h4>依赖包的分类</h4>\n<ul>\n<li>\n<p><strong>dependencies</strong> 业务依赖</p>\n<p>依赖项属于线上的一部分，例如 <code class=\"language-text\">react</code>、<code class=\"language-text\">material-ui</code> 等等，供生产环境使用。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&lt;</span>packageName<span class=\"token operator\">></span> --save</code></pre></div>\n<blockquote>\n<p>npm 5.x 之后，直接执行 <code class=\"language-text\">npm i &lt;packageName&gt;</code> 即可</p>\n</blockquote>\n</li>\n<li>\n<p><strong>devDependencies</strong> 开发依赖</p>\n<p>依赖项只在项目开发时需要，不属于线上代码的一部分，例如 <code class=\"language-text\">webpack</code>、<code class=\"language-text\">babel</code> 等等</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&lt;</span>packageName<span class=\"token operator\">></span> --save-dev</code></pre></div>\n</li>\n<li>\n<p>peerDependencies 同伴依赖</p>\n<p>提示宿主环境安装插件在 <code class=\"language-text\">peerDependencies</code> 中指定依赖的包。</p>\n</li>\n<li>\n<p>bundledDependencies / bundleDependencies 打包依赖</p>\n<p>这种依赖跟 <code class=\"language-text\">npm pack</code> 打包命令相关，必须先在前两种依赖中声明。</p>\n</li>\n<li>\n<p>optionalDependencies 可选依赖</p>\n</li>\n</ul>\n<h4>依赖包的版本号</h4>\n<p>采用 <a href=\"https://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">semver</a> 规范作为依赖版本管理方案，格式一般为：<strong>主版本号.次版本号.修订号(x.y.z)</strong></p>\n<ul>\n<li>\n<p>主版本号 major version</p>\n<p>可能是颠覆性的改动，导致可能会与低版本的 API 或者用法不兼容。</p>\n</li>\n<li>\n<p>次版本号 minor version</p>\n<p>改动通常兼容同一个大版本内的 API 和用法。</p>\n<blockquote>\n<p>如果大版本号是 0，表示处于开发初始阶段，一切都可能被改变。</p>\n</blockquote>\n</li>\n<li>\n<p>修订号 patch</p>\n<p>一般用于修复 bug 和细微的变更，通常要保持向前兼容。</p>\n</li>\n</ul>\n<p>常见的版本格式：</p>\n<ul>\n<li>\n<p>”1.2.3” 精确版本号</p>\n</li>\n<li>\n<p>“^1.2.3” ^ 能够兼容除了最左侧非 0 版本号之外的其他变化</p>\n</li>\n<li>\n<p>“~1.2.3” ~ 如果列出了次版本号，那么只兼容补丁的修改；如果没有列出次版本号，那么兼容 2、3 位的修改</p>\n</li>\n<li>\n<p>“1.x”、“1.X”、“1.<em>”、“1”、“\\</em>”</p>\n<blockquote>\n<p>”*” 、“x” 或者 （空） 表示可以匹配任何版本。 </p>\n<p> “1.x”, “1.*” 和 “1” 表示匹配主版本号为 “1” 的所有版本，因此等价于 ”>= 1.0.0 &#x3C; 2.0.0”。 </p>\n<p> “1.2.x”, “1.2.*” 和 “1.2” 表示匹配版本号以 “1.2” 开头的所有版本，因此等价于 ”>= 1.2.0 &#x3C; 1.3.0”。</p>\n</blockquote>\n</li>\n<li>\n<p>带预发布关键词的版本号</p>\n<blockquote>\n<p>alpha(α)：预览版，或者叫内部测试版；一般不向外部发布，会有很多bug；一般只有测试人员使用。  beta(β)：测试版，或者叫公开测试版；这个阶段的版本会一直加入新的功能；在alpha版之后推出。  rc(release candidate)：最终测试版本；可能成为最终产品的候选版本，如果未出现问题则可发布成为正式版本。</p>\n</blockquote>\n</li>\n</ul>\n<h4>依赖包的版本管理</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 更新某模块主版本下的最新版本</span>\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&lt;</span>packageName<span class=\"token operator\">></span>\n\n<span class=\"token comment\"># 更新到指定版本号</span>\n<span class=\"token function\">npm</span> <span class=\"token function\">install</span> <span class=\"token operator\">&lt;</span>packageName@x.x.x<span class=\"token operator\">></span>\n\n<span class=\"token comment\"># 卸载某个模块</span>\n<span class=\"token function\">npm</span> uninstall <span class=\"token operator\">&lt;</span>packageName<span class=\"token operator\">></span></code></pre></div>\n<blockquote>\n<p>升级和卸载依赖包时，尽量通过命令实现，避免手动修改 <code class=\"language-text\">package.json</code> 中的版本号，<strong>一定不要手动修改 <code class=\"language-text\">package-lock.json</code></strong></p>\n</blockquote>\n<h2>npm scripts 脚本</h2>\n<p>npm 可以在 <code class=\"language-text\">package.json</code> 文件中，使用 <code class=\"language-text\">scripts</code> 字段定义脚本命令。</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"build\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"node build.js\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>基本原理</h4>\n<p>每次执行 <code class=\"language-text\">npm run</code> 时，会自动新建一个 Shell，在这个 Shell 中执行指定的脚本命令。</p>\n<blockquote>\n<p><code class=\"language-text\">npm run</code>  新建的 Shell，会将当前目录中的 node_modules/.bin 子目录加入 <code class=\"language-text\">PATH</code> 变量中，执行结束后再将 <code class=\"language-text\">PATH</code> 变量恢复原样。</p>\n</blockquote>\n<p>因此，当前目录的 <code class=\"language-text\">node_modules/.bin</code> 子目录中的所有脚本，都可以直接使用脚本名调用，而不需要加上路径。</p>\n<blockquote>\n<p><code class=\"language-text\">PATH</code>环境变量，是告诉系统，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到哪些目录下去寻找。</p>\n</blockquote>\n<h4>传参</h4>\n<p>除了第一个可执行的命令，以空格分割的任何字符串（除了一些 shell 的语法）都是参数，并且都能通过<code class=\"language-text\">process.argv</code> 属性访问。</p>\n<blockquote>\n<p>process.argv属性返回一个数组，这个数组包含了启动node进程时的命令行参数。第一个元素为启动node 进程的可执行文件的绝对路径名<a href=\"https://link.juejin.im?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fprocess.html%23process_process_execpath\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">process.execPath</a>，第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> run serve --params     // 参数params将转化成process.env.npm_config_params <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token function\">npm</span> run serve --params<span class=\"token operator\">=</span>123 // 参数params将转化成process.env.npm_config_params <span class=\"token operator\">=</span> 123\n<span class=\"token function\">npm</span> run serve -params      // 等同于--params参数\n\n<span class=\"token function\">npm</span> run serve -- --params  // 将--params参数添加到process.env.argv数组中\n<span class=\"token function\">npm</span> run serve params       // 将params参数添加到process.env.argv数组中\n<span class=\"token function\">npm</span> run serve -- params    // 将params参数添加到process.env.argv数组中</code></pre></div>\n<h4>通配符</h4>\n<p>npm 脚本即 Shell 脚本，所以可以使用 Shell 通配符。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token string\">\"lint\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"jshint *.js\"</span>\n<span class=\"token string\">\"lint\"</span><span class=\"token keyword\">:</span> <span class=\"token string\">\"jshint **/*.js\"</span></code></pre></div>\n<p><code class=\"language-text\">*</code> 表示任意文件名，<code class=\"language-text\">**</code> 表示任意一层子目录。</p>\n<h4>多命令运行</h4>\n<h5>串行执行</h5>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> run script1 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">npm</span> run script2</code></pre></div>\n<blockquote>\n<p>只要一个命令执行失败，则整个脚本终止。</p>\n</blockquote>\n<h5>并行执行</h5>\n<p>多个任务可以同时的平行执行，使用 <code class=\"language-text\">&amp;</code> 符号来连接。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> run script1 <span class=\"token operator\">&amp;</span> <span class=\"token function\">npm</span> run script2</code></pre></div>\n<h4>env 环境变量</h4>\n<p>执行 <code class=\"language-text\">npm scripts</code> 时，<code class=\"language-text\">npm</code> 会设置一些特殊的 <code class=\"language-text\">env</code> 环境变量。<code class=\"language-text\">package.json</code> 中的所有字段都会被设置为以 <code class=\"language-text\">npm_package_</code> 开头的环境变量。例如使用 <code class=\"language-text\">process.env.npm_package_name</code> 可以获取到 <code class=\"language-text\">package.json</code> 中 <code class=\"language-text\">name</code> 字段的值。<code class=\"language-text\">process.env.npm_lifecycle_event</code> 表示当前正在运行的脚本名称。</p>\n<blockquote>\n<p>这些环境变量都只能在 npm run 的脚本执行环境内拿到。</p>\n</blockquote>\n<h4>指令钩子</h4>\n<p>npm 脚本有 <code class=\"language-text\">pre</code> 和 <code class=\"language-text\">post</code> 两个钩子。例如：<code class=\"language-text\">build</code> 脚本命令的钩子就是 <code class=\"language-text\">prebuild</code> 和 <code class=\"language-text\">postbuild</code>。</p>\n<h3>参考</h3>\n<ul>\n<li>\n<p><a href=\"https://juejin.im/post/5d08d3d3f265da1b7e103a4d\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">前端工程化（5）：你所需要的npm知识储备都在这了</a></p>\n</li>\n<li>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/01/npm-install.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">npm 模块安装机制简介</a></p>\n</li>\n<li>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">npm scripts 使用指南</a></p>\n</li>\n</ul>","timeToRead":4,"excerpt":"npm 是目前默认的 Node 包管理工具，在 javaScript 项目开发中得到了广泛使用。node_modulesnpm…","frontmatter":{"title":"exploring npm","date":"July 05, 2019","description":"npm 是目前最流行的 Node 包管理工具，在 javaScript 项目开发中得到了广泛使用。"},"fields":{"slug":"/exploring-npm/"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/exploring-npm/","previous":{"fields":{"slug":"/flex-box/"},"frontmatter":{"title":"Flexbox 布局"}},"next":null}}